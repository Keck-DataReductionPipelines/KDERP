;
; Copyright (c) 2013, California Institute of Technology. All rights
;	reserved.
;+
; NAME:
;	KCWI_STAGE2DARK
;
; PURPOSE:
;	This procedure takes the output from KCWI_STAGE1 and subtracts the
;	master dark frame.
;
; CATEGORY:
;	Data reduction for the Keck Cosmic Web Imager (KCWI).
;
; CALLING SEQUENCE:
;	KCWI_STAGE2DARK, Procfname, Pparfname
;
; OPTIONAL INPUTS:
;	Procfname - input proc filename generated by KCWI_PREP
;			defaults to './redux/kcwi.proc'
;	Pparfname - input ppar filename generated by KCWI_PREP
;			defaults to './redux/kcwi.ppar'
;
; KEYWORDS:
;	VERBOSE	- set to verbosity level to override value in ppar file
;	DISPLAY - set to display level to override value in ppar file
;
; OUTPUTS:
;	None
;
; SIDE EFFECTS:
;	Outputs processed files in output directory specified by the
;	KCWI_PPAR struct read in from Pparfname.
;
; PROCEDURE:
;	Reads Pparfname to derive input/output directories and reads the
;	'*.proc' file in output directory to derive the list
;	of input files and their associated master dark files.  Each input
;	file is read in and the required master dark is generated before
;	subtraction.
;
; EXAMPLE:
;	Perform stage2dark reductions on the images in 'night1' directory and 
;	put results in 'night1/redux':
;
;	KCWI_STAGE2DARK,'night1/redux/kcwi.ppar'
;
; MODIFICATION HISTORY:
;	Written by:	Don Neill (neill@caltech.edu)
;	2013-MAY-10	Initial version
;	2013-SEP-14	Use ppar to pass loglun
;	2014-APR-01	Now scale dark by exposure time
;	2014-APR-03	Uses master ppar and link files
;	2014-SEP-29	Added infrastructure to handle selected processing
;	2017-MAY-24	Changed to proc control file and removed link file
;	2017-DEC-18	Added scattered light subtraction
;-
pro kcwi_stage2dark,procfname,ppfname,help=help,verbose=verbose, display=display
	;
	; setup
	pre = 'KCWI_STAGE2DARK'
	startime=systime(1)
	q = ''	; for queries
	;
	; help request
	if keyword_set(help) then begin
		print,pre+': Info - Usage: '+pre+', Proc_filespec, Ppar_filespec'
		print,pre+': Info - default filespecs usually work (i.e., leave them off)'
		return
	endif
	;
	; get ppar struct
	ppar = kcwi_read_ppar(ppfname)
	;
	; verify ppar
	if kcwi_verify_ppar(ppar,/init) ne 0 then begin
		print,pre+': Error - pipeline parameter file not initialized: ',ppfname
		return
	endif
	;
	; directories
	if kcwi_verify_dirs(ppar,rawdir,reddir,cdir,ddir,/nocreate) ne 0 then begin
		kcwi_print_info,ppar,pre,'Directory error, returning',/error
		return
	endif
	;
	; check keyword overrides
	if n_elements(verbose) eq 1 then $
		ppar.verbose = verbose
	if n_elements(display) eq 1 then $
		ppar.display = display
	;
	; log file
	lgfil = reddir + 'kcwi_stage2dark.log'
	filestamp,lgfil,/arch
	openw,ll,lgfil,/get_lun
	ppar.loglun = ll
	printf,ll,'Log file for run of '+pre+' on '+systime(0)
	printf,ll,'DRP Ver: '+kcwi_drp_version()
	printf,ll,'Raw dir: '+rawdir
	printf,ll,'Reduced dir: '+reddir
	printf,ll,'Calib dir: '+cdir
	printf,ll,'Data dir: '+ppar.datdir
	printf,ll,'Filespec: '+ppar.filespec
	printf,ll,'Ppar file: '+ppfname
	if ppar.clobber then $
		printf,ll,'Clobbering existing images'
	printf,ll,'Verbosity level   : ',ppar.verbose
	printf,ll,'Display level     : ',ppar.display
	;
	; read proc file
	kpars = kcwi_read_proc(ppar,procfname,imgnum,count=nproc)
	;
	; interactive?
	interact = (ppar.display ge 2)
	;
	; gather configuration data on each observation in reddir
	kcwi_print_info,ppar,pre,'Number of input images',nproc
	;
	; loop over images
	for i=0,nproc-1 do begin
		;
		; image to process (in reduced dir)
		obfil = kcwi_get_imname(kpars[i],imgnum[i],'_int',/reduced)
		;
		; check if input file exists
		if file_test(obfil) then begin
			;
			; read configuration
			kcfg = kcwi_read_cfg(obfil)
			;
			; final output file
			ofil = kcwi_get_imname(kpars[i],imgnum[i],'_intd',/reduced)
			;
			; trim image type
			kcfg.imgtype = strtrim(kcfg.imgtype,2)
			;
			; check if output file exists already
			if kpars[i].clobber eq 1 or not file_test(ofil) then begin
				;
				; do we plot?
				do_plots = (ppar.display ge 1 or kpars[i].saveplots ge 2)
				;
				; print image summary
				kcwi_print_cfgs,kcfg,imsum,/silent
				if strlen(imsum) gt 0 then begin
					for k=0,1 do junk = gettok(imsum,' ')
					imsum = string(i+1,'/',nproc,format='(i3,a1,i3)')+' '+imsum
				endif
				print,""
				print,imsum
				printf,ll,""
				printf,ll,imsum
				flush,ll
				;
				; report input file
				kcwi_print_info,ppar,pre,'input reduced image',obfil,format='(a,a)'
				;
				; read in image
				img = mrdfits(obfil,0,hdr,/fscale,/silent)
				;
				; get dimensions
				sz = size(img,/dimension)
				;
				; does this image need dark subtraction?
				do_dark = kcwi_do_dark(img,hdr,kpars[i],interact=interact)
				;
				; get exposure time
				exptime = kcfg.exptime
				;
				; read variance, mask images
				vfil = kcwi_get_imname(kpars[i],imgnum[i],'_var', $
							/reduced)
				if file_test(vfil) then begin
					var = mrdfits(vfil,0,varhdr,/fscale, $
							/silent)
				endif else begin
					var = fltarr(sz)
					var[0] = 1.	; give value range
					varhdr = hdr
					kcwi_print_info,ppar,pre, $
					    'variance image not found for: '+ $
					    obfil,/warning
				endelse
				mfil = kcwi_get_imname(kpars[i],imgnum[i],'_msk', $
							/reduced)
				if file_test(mfil) then begin
					msk = mrdfits(mfil,0,mskhdr,/silent)
				endif else begin
					msk = intarr(sz)
					msk[0] = 1	; give value range
					mskhdr = hdr
					kcwi_print_info,ppar,pre, $
					    'mask image not found for: '+ $
					    obfil,/warning
				endelse
				;
				; add history record
				sxaddpar,mskhdr,'HISTORY','  '+pre+' '+systime(0)
				sxaddpar,varhdr,'HISTORY','  '+pre+' '+systime(0)
				sxaddpar,hdr,'HISTORY','  '+pre+' '+systime(0)
				;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				; STAGE 2-A: DARK SUBTRACTION
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;
				; let's read in or create master dark
				if do_dark and (1 eq 0) then begin 	; skip for now
					;
					; do we have a master dark file name?
					if strtrim(kpars[i].masterdark,2) ne '' then begin
						;
						; master dark filename
						mdfile = kpars[i].masterdark
						;
						; build master dark if needed
						if not file_test(mdfile) then begin
							;
							; master dark ppar filename
							mdppfn = repstr(mdfile,'.fits','.ppar')
							;
							; read in params
							dpar = kcwi_read_ppar(mdppfn)
							dpar.loglun  = kpars[i].loglun
							dpar.verbose = kpars[i].verbose
							kpar.display = kpars[i].display
							;
							; create master dark
							kcwi_make_dark,dpar
						endif
						;
						; read in master dark
						mdark = mrdfits(mdfile,0,mdhdr,/fscale,/silent)
						;
						; get exposure time
						dexptime = sxpar(mdhdr,'TELAPSE')
						;
						; read in master dark variance
						mdvarfile = strmid(mdfile,0,strpos(mdfile,'.fit')) + '_var.fits'
						mdvar = mrdfits(mdvarfile,0,mvhdr,/fscale,/silent)
						;
						; read in master dark mask
						mdmskfile = strmid(mdfile,0,strpos(mdfile,'.fit')) + '_msk.fits'
						mdmsk = mrdfits(mdmskfile,0,mmhdr,/fscale,/silent)
						;
						; scale by exposure time
						fac = 1.0
						if exptime gt 0. and dexptime gt 0. then $
							fac = exptime/dexptime $
						else	kcwi_print_info,ppar,pre,'unable to scale dark by exposure time',/warning
						kcwi_print_info,ppar,pre,'dark scale factor',fac,form='(a,f9.3)'
						;
						; do subtraction
						img = img - mdark*fac
						;
						; handle variance
						var = var + mdvar
						;
						; handle mask
						msk = msk + mdmsk
						;
						; update header
						fdecomp,mdfile,disk,dir,root,ext
						sxaddpar,mskhdr,'DARKSUB','T',' dark subtracted?'
						fxaddpar,mskhdr,'MDFILE',root+'.'+ext,' master dark file applied',before='HISTORY'
						sxaddpar,mskhdr,'DARKSCL',fac,' dark scale factor'
						;
						; update header
						sxaddpar,varhdr,'DARKSUB','T',' dark subtracted?'
						fxaddpar,varhdr,'MDFILE',root+'.'+ext,' master dark file applied',before='HISTORY'
						sxaddpar,varhdr,'DARKSCL',fac,' dark scale factor'
						;
						; update header
						sxaddpar,hdr,'DARKSUB','T',' dark subtracted?'
						fxaddpar,hdr,'MDFILE',root+'.'+ext,' master dark file applied',before='HISTORY'
						sxaddpar,hdr,'DARKSCL',fac,' dark scale factor'
						;
						; handle the case when no dark frames were taken
					endif else begin
						;
						; in case we do scattered light
						sxaddpar,mskhdr,'DARKSUB','F',' dark subtracted?'
						sxaddpar,varhdr,'DARKSUB','F',' dark subtracted?'
						sxaddpar,hdr,'DARKSUB','F',' dark subtracted?'
						;
						if strpos(kcfg.obstype,'cal') ge 0 then $
							kcwi_print_info,ppar,pre,'cals do not get dark subtracted: '+ $
								kcfg.obsfname,/info $
						else	kcwi_print_info,ppar,pre,'cannot associate with any master dark: '+ $
								kcfg.obsfname,/warning
					endelse
				endif else begin
					;
					; in case we do scattered light
					sxaddpar,mskhdr,'DARKSUB','F',' dark subtracted?'
					sxaddpar,varhdr,'DARKSUB','F',' dark subtracted?'
					sxaddpar,hdr,'DARKSUB','F',' dark subtracted?'
					;
					if strpos(kcfg.obstype,'cal') ge 0 then $
						kcwi_print_info,ppar,pre,'cals do not get dark subtracted: '+ $
							kcfg.obsfname,/info $
					else	kcwi_print_info,ppar,pre,'cannot associate with any master dark: '+ $
							kcfg.obsfname,/warning
				endelse
				flush,ll
				;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				; BEGIN STAGE 2-B: SCATTERED LIGHT SUBTRACTION
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;
				; only do scattered light subtraction only if N&S mask not in
				do_scat = (kcfg.nasmask eq 0)
				;
				; should we subtract scattered light?
				if do_scat then begin
					;
					; get x range of scattered light region
					sz = size(img,/dim)
					x0 = sz[0] / 2 - 180 / kcfg.xbinsize
					x1 = sz[0] / 2 + 180 / kcfg.xbinsize
					;
					; get y ranges (fit in two pieces)
					y0 = 0
					y1 = (sz[1]/2) - 1
					y2 = y1 + 1
					y3 = sz[1] - 1
					;
					; fitted x values
					fx = findgen(sz[1])
					;
					; scattered light and variance vectors
					simg = img[x0:x1,y0:y3]
					vimg = var[x0:x1,y0:y3]
					;
					; get scattered light profile
					slp = median(simg,dimen=1)
					elp = sqrt(median(vimg,dimen=1))
					;
					; are there dark signatures?
					if do_dark then begin
						;
						; fit in two pieces
						;
						; piece one
						;
						; fitting range
						fx1 = fx[y0:y1]
						;
						; breakpoints for b-spline
						bkpta=min(fx1)+findgen(100)*(max(fx1)-min(fx1))/100.
						bkptb=min(fx1)+findgen(20)*(max(fx1)-min(fx1))/20.
						rez = where(bkpta gt bkptb[19])
						bkpt = [bkptb,bkpta[rez]]
						;
						; fit and get results
						res = bspline_iterfit(fx1,slp[y0:y1],fullbkpt=bkpt)
						scat1 = bspline_valu(fx1,res)
						;
						; piece two
						;
						; fitting range
						fx2 = fx[y2:y3] - min(fx[y2:y3])
						;
						; breakpoints for b-spline
						bkpta=min(fx2)+findgen(100)*(max(fx2)-min(fx2))/100.
						bkptb=min(fx2)+findgen(20)*(max(fx2)-min(fx2))/20.
						rez = where(bkpta lt bkptb[1])
						bkpt = [bkpta[rez],bkptb[1:*]]
						;
						; fit and get results
						res = bspline_iterfit(fx2,slp[y2:y3],fullbkpt=bkpt)
						scat2 = bspline_valu(fx[y2:y3]-min(fx[y2:y3]),res)
						;
						; assemble scattered light profile
						scat = [scat1,scat2]
					;
					; no dark signatures
					endif else begin
						;
						; fit in one piece
						;
						; break points for bspline
						bkpt=min(fx)+findgen(40)*(max(fx)-min(fx))/40.
						res = bspline_iterfit(fx,slp,fullbkpt=bkpt)
						scat = bspline_valu(fx,res)
					endelse	; no dark signatures
					;
					; plot if display set
					if do_plots then begin
						deepcolor
						!p.background=colordex('white')
						!p.color=colordex('black')
						yrn = get_plotlims([slp,elp])
						if yrn[0] gt 0 then yrn[0] = 0.
						plot,fx,slp,/xs,psym=1,xtitle='ROW',ytitle='Scattered Light (e-)', $
							title='Image: '+strn(imgnum[i]), $
							charth=2,charsi=1.5,xthi=2,ythi=2,yran=yrn
						oplot,fx,elp,color=colordex('blue')
						oplot,fx,scat,thick=3,color=colordex('red')
						kcwi_legend,['Data', 'Fit', 'Err'],thick=[1,3,1], $
							charthi=2,charsi=1.5, $
							color=[colordex('C'),colordex('R'),colordex('B')], $
							linesty=[0,0,0]
						;
						; LEVEL 2 output
						if kpars[i].saveplots ge 2 then begin
							plotfn = strmid(ofil,0,strpos(ofil,'.fits'))+'_scat.png'
							write_png,plotfn,tvrd(/true)
							kcwi_print_info,ppar,pre,'saved plot to',plotfn,format='(a,a)'
						endif
						;
						; make interactive if display greater than 1
						if interact then begin
							q = ''
							read,'Next? (Q-quit prompting for plots, <cr>-next): ',q
							if strupcase(strmid(q,0,1)) eq 'Q' then interact = 0
						endif
					endif
					;
					; subtract scat
					for xi=0,sz[0]-1 do $
						img[xi,y0:y3] = img[xi,y0:y3] - scat
					;
					; update headers
					sxaddpar,mskhdr,'SCATCOR','T',' scattered light subtracted?'
					sxaddpar,varhdr,'SCATCOR','T',' scattered light subtracted?'
					sxaddpar,hdr,'SCATCOR','T',' scattered light subtracted?'
					;
					; log
					kcwi_print_info,ppar,pre,'scattered light subtracted'
				endif else begin
					sxaddpar,mskhdr,'SCATCOR','F',' scattered light subtracted?'
					sxaddpar,varhdr,'SCATCOR','F',' scattered light subtracted?'
					sxaddpar,hdr,'SCATCOR','F',' scattered light subtracted?'
					;
					; log
					kcwi_print_info,ppar,pre,'scattered light NOT subtracted'
				endelse
				;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				; END   STAGE 2-B: SCATTERED LIGHT SUBTRACTION
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;
				; write out results?
				if do_scat or do_dark then begin
					;
					; write out dark corrected mask image
					ofil = kcwi_get_imname(kpars[i],imgnum[i],'_mskd',/nodir)
					kcwi_write_image,msk,mskhdr,ofil,kpars[i]
					;
					; output dark corrected variance image
					ofil = kcwi_get_imname(kpars[i],imgnum[i],'_vard',/nodir)
					kcwi_write_image,var,varhdr,ofil,kpars[i]
					;
					; write out dark corrected intensity image
					ofil = kcwi_get_imname(kpars[i],imgnum[i],'_intd',/nodir)
					kcwi_write_image,img,hdr,ofil,kpars[i]
				endif
			;
			; end check if output file exists already
			endif else begin
				kcwi_print_info,ppar,pre,'file not processed: '+obfil+' type: '+kcfg.imgtype,/warning
				if kpars[i].clobber eq 0 and file_test(ofil) then $
					kcwi_print_info,ppar,pre,'processed file exists already: '+ofil,/warning
			endelse
		;
		; end check if input file exists
		endif else $
			kcwi_print_info,ppar,pre,'input file not found: '+obfil,/error
	endfor	; loop over images
	;
	; report
	eltime = systime(1) - startime
	print,''
	printf,ll,''
	kcwi_print_info,ppar,pre,'run time in seconds',eltime
	kcwi_print_info,ppar,pre,'finished on '+systime(0)
	;
	; close log file
	free_lun,ll
	;
	return
end	; kcwi_stage2dark
